:figure-caption: Рисунок
:table-caption: Таблица
= Курсовой проект
:toc:
:toc-title: Оглавление

Тема работы: *Разработка устройства измерения влажности почвы*

Выполнили студенты группы КЭ-413: Макаров А.А., Мотов Г.А. +

= *Задание к курсовой работы:* +

Для работы использовать отладочную плату _XNUCLEO-F411RE_. +

Питание платы должно быть автономным и подаваться с солнечный батарей. +

Устройство должно измерять влажность почвы:

* Для измерения должен использоваться встроенный АЦП микроконтроллера STM32F411.
* Период измерения должен составлять 100 мс.
* Для получения кодов АЦП должен использоваться механизм DMA.
* Для измерения влажности использовать датчик влажности почвы _Moisture Sensor_.
* К измеренному значению должен быть применен цифровой фильтр.

.Формула цифрового фильтра.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::Ajhvekf.png[Sunset]

где _dt_ - 100 мс;

_Value_ - текущее нефильтрованное измеренное значение влажности;

_oldValue_ - предыдущее фильрованное значение;


Передача значений по беспроводному интерфейсу должна осуществляться через модуль _BlueTooth Bee HC-06_
или _I/O Expansion Shield_.

* Для этого общение с платой должно осуществляться через USART2.

* Данные должны выводиться в формате: _"Влажность почвы:" ХХХ.ХХ_ [Units].

Архитектура программы представленна в видее UML диаграмм в пакете StarUML.

Приложение должно быть написано на языке С+ с использованием компилятора ARM 8.40.2.

При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++ обертка над ней.

= Анализ требований к разработке


== Для разработки должна использоваться отладочная плата XNUCLEO-F411RE

NUCLEO-F411RE – это отладочная плата от компании Waveshare с поддержкой Arduino, которая позволит изучить возможности микроконтроллера STM32F411RET6 на базе ядра Cortex-M3.

.Платы XNUCLEO-F411RE.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::Plata.png[Sunset]

Для разработки будет использоваться отладочная плата XNUCLEO-F411RE, производства Waveshare Electronics. +
В основе платы – ARM Cortex-M4 микроконтроллер STM32F411RET6. Эта отладочная плата представляет собой гибкую платформу, позволяющую разработчикам реализовать собственные идеи и в кратчайшие сроки сделать прототип будущего изделия. +
Разъемы ST Morpho платы XNUCLEO-F411RE обеспечивают полный доступ к линиям портов ввода/вывода (I/O) и дальнейшее периферийное расширение. Изделие поставляется с отдельным модулем ST-Link/ V2.

Технические характеристики микроконтроллера STM32F411RET6:

*	ядро: ARM 32-Бит Cortex-M4;
*	рабочая частота: 100МГц;
*	рабочее напряжение: 1.7…3.6В;
*	память: 512кБ Flash, 128кБ SRAM;
*	интерфейсы: 1 x SDIO, 1 x USB 2.0 FS, 5 x SPI or 5 x I2S, 3 x USART, 3 x I2C;
*	АЦП/ЦАП: 1 x АЦП (12 Бит, 16 каналов).

Остальные технические характеристики:

*	SPX3819M5: регулятор напряжения 3,3 В;
*	AMS1117-5.0: регулятор напряжения 5,0 В;
*	CP2102: преобразователь USB в UART;
*	разъем Arduino: для подключения щитов Arduino;
*	интерфейс ICSP: Arduino ICSP;
*	USB TO UART: для отладки;
*	разъем USB: интерфейс связи USB;
*	интерфейс SWD: для программирования и отладки;
*	заголовки ST Morpho: доступ к VCC, GND и всем входам / выходам, прост в расширении;
*	6-12 В постоянного тока;
*	пользовательская кнопка;
*	кнопка сброса;
*	индикатор питания;
*	пользовательский светодиод;
*	500 мА быстрый самовосстанавливающийся предохранитель;
*	индикатор Rx / Tx последовательного порта;
*	кристалл 8 МГц;
*	кристалл 32,768 кГц.

== Питание платы должно быть автономным и подаваться с солнечный батарей

Питание будет подаваться с модуля управления солнечной энергией, для панели солнечных батарей 6V~24V.
Этот модуль управления солнечной энергией может заряжать аккумуляторную литиевую батарею 3.7 V через солнечную панель или USB-соединение и обеспечивает регулируемый выход 5V/1A.

.Модуль управления солнечной энергией.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::Modul.png[Sunset]

Характеристики:

* Напряжение солнечной панели (SOLAR IN): 6V ~ 24V;
* Зарядные устройства: Солнечная панель, адаптер питания, USB;
* USB-интерфейс зарядки: Micro USB: 5V/1A;
* Внутренняя литий-батарея: 3.7 V 14500 Li-battery;
* Входное напряжение USB: 5V (интерфейс Micro USB);
* Выход 5V: 5V / 1A (USB OUT, GPIO);
* Защита от напряжения отключения заряда: 4.2 V ± 1％;
* Напряжение защиты от перегрузки: 2.9V ± 1％;
* Эффективность заряда солнечной панели: 78%;
* Эффективность зарядки USB: 82%;
* Максимальный ток покоя: <2мА;
* Рабочая температура: -40℃ ~ 85℃.

== Датчик влажности Moisture Sensor

Для измерения влажности почвы в работе используетcя датчик влажности _Moisture Sensor_ производителя WaveShare.

.Датчик влажности Moisture Sensor.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::datchik.jpg[Sunset]

Датчик влажности сконструирован в виде «вилки», что позволяет легко его вставлять в почву. Выходное напряжение повышается наряду с увеличением уровня влажности. Датчики этого типа широко применяются в автоматических системах полива и системах обнаружения влаги.

Характеристики:

* Глубина обнаружения: 38мм;

* Напряжение питания: 2В-5В;

* Монтажные отверстия: 2мм;

* Размеры: 20 х 51мм.

==  _BlueTooth_ модуль

Передача данных осуществляется с помощью модуля _BlueTooth Bee V2.0_ производителя _ElecFreaks_.
Данный беспроводной модуль  обеспечивает простой интерфейс для подключения к различным приложениям микроконтроллеров.
Модуль предоставляет способ беспроводного подключения к ПК или телефону для передачи/приема встроенных данных, таких как данные GPS, показания напряжения АЦП и другие параметры.

.Модуль Bluetooth Bee Slave.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::BlueTooth.png[Sunset]

* Напряжение питания может составлять от 3,6 до 6 В постоянного тока.
* Модуль легко подключается к любому стандартному устройству Bluetooth, необходимо найти
и ввести код доступа "1234".
* Скорость передачи данных составляет 38400 бит/с.
* Модуль не требует дополнительной настройки.

=== Общение с платной модуля BlueTooth должна осуществляться через USART2

Режим встроенного загрузчика используется для программирования флэш-памяти с использованием интерфейса: USART2 +
В модуле USART можно настраивать следующие параметры:

*	Скорость обмена до 4 мбит/c
*	Контроль четности
*	1 или 2 стоповых битов
*	8 или 9 бит данных
*	Запросы на детектирование ошибок приемо-передачи
*	Прерывания по приему, передачи, ошибкам передачи

Для настройки и работы модуля UART нужны всего несколько регистров

*	USART_CR1/CR2/CR3 - регистр настройки 1
*	USART_DR - регистр принятого символа (регистр данных)
*	USART_BRR – регистр настройки скорости передачи
*	USART_SR - регистр состояния

== Приложение должно быть написано на языке С++ с использование компилятора ARM 9.10

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF. Различные типы памяти могут быть расположены по эти адресам. Обычно микроконтроллер имеет постоянную память, из которой можно только читать (ПЗУ) и оперативную память, из которой можно читать и в которую можно писать (ОЗУ). Также часть адресов этой памяти отведены под регистры управления и регистры периферии. +
Микроконтроллер на ядре Cortex M4 выполнен по Гарвардской архитектуре, память здесь разделена на три типа:

*	*ПЗУ* (FLASH память в которой храниться программа)
*	*ОЗУ* память для хранения временных данных (туда же можно по необходимости переместить программу и выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с периферией и
*	Память для хранения постоянных данных ЕЕPROM.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера.

Семейство ARM9 core состоит из ARM9TDMI, ARM940T, ARM9E-S, ARM966E-S, ARM920T, ARM922T, ARM946E-S, ARM9EJ-S, ARM926EJ-S, ARM968E-S, ARM996HS. +
Версия 9.10 полного набора инструментов разработки IAR Embedded Workbench for Arm добавляет поддержку 64-битных ядер Arm, включая Arm Cortex-A35, Cortex-A53, Cortex-A55, Cortex-A57 и Cortex-A72.

== При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++ обертка над ней

FreeRTOS – бесплатная многозадачная операционная система реального времени (ОСРВ) для встраиваемых систем. Портирована на 35 микропроцессорных архитектур. +
Планировщик системы очень маленький и простой, однако можно задать различные приоритеты процессов, вытесняющую и не вытесняющую многозадачность. Ядро системы умещается в 3 -4 файлах. +
FreeRTOS межзадачная коммуникация (упорядоченная передача информации от одной задачи другой задаче)

*	События (Как только событие произошло - задача ожидающая это событие переходи в состояние ГОТОВНОСТИ и планировщик в зависимости от приоритета запускает её на исполнение)
*	Очереди
*	Нотификация задачи

Так как мы будем работать именно с FreeRTOS, то надо подключить бибилиотеку: #include "rtos.hpp"

== UML-диаграммы

_Унифицированный язык моделирования (Unified Modeling Language, UML)_ является графическим языком для визуализации, специфицирования, конструирования и документирования систем, в которых большая роль принадлежит программному обеспечению.

С помощью _UML_ можно детально описать систему, начиная разработку с концептуальной модели с ее бизнес - функциями и процессами, а также описать особенности реализации системы, такие как классы программного обеспечения системы, схему базы
данных.

Нотация обеспечивает семантику языка, является способом унификации обозначений визуального моделирования, обеспечивает всестороннее представление системы, которое сравнительно легко и свободно воспринимается человеком.

Моделирование с помощью _UML_ осуществляется поэтапным построением ряда диаграмм, каждая из которых отражает какую-то часть или сторону системы либо ее замысла.

Диаграмма – это графическое представление множества элементов. Обычно диаграмма изображается в виде графа с вершинами (сущностями) и ребрами (отношениями).
Диаграммы подчиняются нотации _UML_ и изображаются в соответствии с ней.

Основные диаграммы _UML_:

* вариантов использования (use case diagram);
* классов (class diagram);
* кооперации (collaboration diagram);
* последовательности (sequence diagram);
* состояний (statechart diagram);
* деятельности (activity diagram);
* компонентов (component diagram);
* развертывания (deployment diagram).

.Архитектура устройства для измерения влажности почвы построенная в StarUML.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::Main.png[Sunset]

Построения этих диаграмм достаточно для полного моделирования системы.

_StarUML_ поддерживает одиннадцать различных типов диаграмм, принятых в
нотации _UML_, а также подход _MDA_ (модельно – настраиваемая архитектура),
предлагает настройку параметров пользователя для адаптации среды разработки,
поддерживает расширения, предоставляет различного рода модули, расширяющие
возможности StarUML.

Концепция _MDA (Model Driven Architecture)_ призвана обеспечить общую основу для описания и
использования большинства существующих стандартов, не ограничивая разработчиков в выборе
конкретных технологий. Интеграция стандартов достигается за счет: введения концепции
платформно-независимой модели приложения; использования унифицированного инструмента
для описания таких моделей.

Опишем основные элементы нотации _UML_.

* _Класс_ – это описание группы объектов с общими свойствами (атрибутами), поведением (операциями),
отношениями с другими объектами и семантикой.
Каждый класс является шаблоном для создания объекта. А каждый объект – это экземпляр класса.
Каждый объект может быть экземпляром только одного класса.
Имя атрибута может быть произвольной текстовой строкой. Имя является единственным обязательным
элементом при задании атрибута.

* _Видимость(visibility)_ — качественная характеристика описания свойств класса,
характеризующая потенциальную возможность других объектов модели использовать это
свойство (атрибут или операцию).
Видимость в языке UML обозначается с помощью квантора видимости (visibility),
который может принимать одно из 4-х возможных значений и отображаться при помощи
специальных символов.

** _Открытый (public)_ атрибут виден всем остальным классам. Любой класс, связанный
с данным в рамках диаграммы или пакета, может просмотреть или изменить значение атрибута.
Обозначается символом «+» перед именем атрибута.

** _Защищенный (protected)_. Любой потомок данного класса может пользоваться его защищенными
свойствами. Обозначается знаком «#» перед именем атрибута.

** _Закрытый (private)_. Атрибут с этой областью видимости недоступен или не виден для
всех классов без исключения.Обозначается знаком «-» перед именем атрибута.

** _Пакетный (package)_. Атрибут является открытым, но только в пределах своего пакета.
В StarUML данный атрибут обозначается значком «~»

* Ассоциация – это семантическая связь между классами. На диаграмме ее рисуют в виде
обычной линии. Ассоциация может быть однонаправленной или двунаправленной. В первом
случае ее изображают в виде стрелки, показывающей направление связи. Во втором случае –
двойной стрелки либо просто линии без стрелок.
Если между классами создана двунаправленная связь, то каждый из них видит открытые атрибуты
и операции других классов.

* Агрегация – специальная форма ассоциации, которая служит для представления отношения типа
"часть - целое" между агрегатом (целое) и его составной частью.

* Композицией называется форма агрегирования с четко выраженным отношением владения,
причем время жизни частей и целого совпадают.
Как только будет уничтожен объект целое, так вместе с ним будет уничтожен объект часть.
На диаграммах композиция показывается также, как и агрегация, но только
ромб должен быть закрашен.


* Обобщение – это отношение наследования между двумя элементами модели.
Оно дает классу возможность наследовать открытые или защищенные атрибуты и операции
суперкласса (класса от которого наследуются атрибуты и операции). Помимо наследуемых
каждый класс может иметь свои атрибуты и операции.
На диаграммах обобщение изображается в виде стрелки с не закрашенным треугольником у
суперкласса, идущей от потомка.

.Детальная архитектура устройства построенная в StarUML.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::Main2.png[Sunset]

== Язык программирования С++

Язык программирования — формальный язык, предназначенный для записи компьютерных программ.
Язык программирования определяет набор лексических, синтаксических и семантических правил,
определяющих внешний вид программы и действия, которые выполнит исполнитель под её управлением.

C++  — компилируемый, статически типизированный язык программирования
общего назначения, на котором можно создавать программы любого уровня сложности.

Синтаксис C++ унаследован от языка C. Одним из принципов разработки было
сохранение совместимости с C. Тем не менее, C++ не является в строгом смысле
надмножеством C.
C++ повлиял на многие языки программирования, в их числе: Java, C#, D.
C++ имеет богатую стандартную библиотеку, которая включает в себя распространённые контейнеры и алгоритмы, ввод-вывод, регулярные выражения, поддержку многопоточности и другие возможности.

== Среда разработки IAR Embedded Workbench

IAR Embedded Workbench – это интегрированная отладочная среда разработки приложений _(IDE)_,
обладающая рядом неоспоримых преимуществ. К ним относятся удобный пользовательский интерфейс,
генерирование компактного объектного кода, поддержка различных типов _RTOS_ (Micrium μC/OS,II,
OSEC ORTI) и _JTAG-адаптеров_ третьих фирм (OLIMEX, Phyton, ASHLING), а также
подробная техническая документация. Компания _IAR Systems_ поставляет _IDE_ для широкого
спектра 8-, 16-, 32-разрядных микропроцессоров таких фирм, как _ARM_, _Infineon_, _Cypress_,
_Atmel_, _Analog Devices_, _Microchip Technologies_, _Ember_, _NXP_, _National Semiconductor_,
_STMicroelectronics_, _Texas Instruments_, _Renesas_, _Freescale_, _Silicon Labs_ и др.

Типовой комплект IAR Embedded Workbench содержит: C/C++ компилятор,
транслятор языка ассемблера, компоновщик, управляющие программы для работы
с библиотечными подпрограммами, редактор, менеджер проектов, C-SPY отладчик.
Для большинства IDE поставка возможна в трех вариантах: Standard (полная профессиональная
версия), Baseline (ограничения на объем генерируемого кода, отсутствие годовой
технической поддержки) или Limited (не входят C-SPY отладчик, RTOS-модули, отсутствует
поддержка MISRA C).

== Измерение влажности и его методы

Основной показатель присутствия влаги в почве – влажность.
Это процентное соотношение воды и сухой массы в грунте. Методы вычисления влажности
классифицируются на несколько групп:

* Первая – изъятие образцов земли и измерение влажности в лабораторных условиях.
* Вторая – использование приборов, установленных в грунте при естественном залегании.

Влага – основной фактор, оказывающий влияние на плодородность земли.
Влажность почвы определяют для того, чтобы узнать:

* количество содержания влаги в земле;
* структуру грунта: плотность, эластичность;
* какие удобрения необходимы для грунта;
* какая культура может выращиваться на определенном участке;
* предупредить выветривание земли из-за чрезмерной сухости;
* определить способность грунта к сельскохозяйственным, агротехническим процессам.

Существует 5 способов проверки количества воды в грунте. Самые популярные из них:

* _Гравиметрические_ – основаны на получении воды из грунта посредством химической реакции
и испарения. Более точные результаты достигаются с использованием сушильной емкости.
* _Электромагнитные_ – связаны с действием влажности на электрические характеристики земли.
Существует множество сенсоров, реагирующие на поляризацию, сопротивление или на два свойства
одновременно. Приборы широко используются для определения влаги в верхнем слое, при глубинных
исследованиях четкая корреляция отсутствует.
* _Микроволновые_ – базируется на низкой тепло- и электропроводности воды, характеристики
излучения связаны с влагоемкостью. Минус – высокая цена приборов.
* _Тензометрический_ – основан на возможности грунта впитывать влажность.
Устройства определяют колебания влагоемкости земли. Ноль означает, что грунт насыщен водой.
* _Термический_ – связан с тепловой инерцией почвы, ее влажности. Диагностика выполняется
посредством портативных приборов.

Аналого-цифровым преобразованием является процесс, при котором входная величина, преимущественно
физическая преобразуется в соответствующее числовое значение. Таким образом, аналого-цифровой
преобразователь является устройством, которое выполняет это преобразование. То есть на входе, могут
быть такие величины как ток, напряжение, сопротивление, емкость, угол поворота.
Аналого-цифровой преобразователь обладает многими характеристиками. К основным из них можно
отнести разрядность и частоту преобразования. Частота преобразования измеряется в отсчетах в секунду,
а разрядность в битах. Эти две величины связанны друг с другом: чем больше значение эффективной
разрядности, тем меньше частота преобразования.

Модуль _DMA_ - это блок прямого доступа к памяти (ПДП). Его суть заключается в том, чтобы по команде
от периферии или ядра взять и скопировать часть памяти с одного места на другой. Во время этой
операции основной процессор может выполнять другие задачи, прерываясь только в том случае, когда
транзакция закончилась и новый блок данных целиком доступен для обработки. Большие объемы данных
могут быть переданы без значительного ухудшения общей производительности системы.

Для использования АЦП через модуль DMA необходимо:

** Подключить АЦП и _DMA_ к шине тактирования
** Настроить порты, по которым будут сниматься данные в альтернативный режим
** Устанавить разрядность АЦП
** Выбирать тип преобразования АЦП
** Устанавить количество измерений АЦП
** Выбирать канал, по которому будет производиться измерение АЦП
** Устанавлить скорость дискретизации АЦП
** Указать адрес переферии для модуля _DMA_
** Задать адрес памяти для модуля _DMA_
** Указать направление передачи данных из переферии в память
** Указать количество посылаемых сообщений
** Указать размерность данных переферии и памяти
** Устанавить приоритет
** Устанавить режим работы модуля _DMA_
** Разрешить работу выбранного канала _DMA_
** Запустить АЦП на преобразование
** Включить считывание по _DMA_
** Включить АЦП

Перед дальнейшей обработкой, данные, полученные с АЦП должны быть отфильтрованы с использованием цифрового
фидьтра. Условия, которым должен удовлетворять цифровой фильтр представлены в техническом задании.

В качестве датчика влажности выбран датчик _Moisture sensor_ производителя _Waveshare_. Он производит
измерения влажности почвы электромагнитным способом. Для корректного
получения данных с датчика необходимо произвести его калибровку. Для произведения калибровки были произведены
опытные измерения. Их суть заключается в том, что был
произведен замер кодов в зависимости от влажности почвы с шагом 10%, а после это проведена обработка
полученных значений и сформирован полином, по которому производится преобразование
полученных кодов АЦП в процентное значение влажности. Для этого была подготовленна сухая
почва массой 100 грамм. Затем были проведены замеры влажности в сухой почве, и в почве содержащей в себе
10% массы воды от всей массы почвы. Далее процентное содержание массы воды каждый раз увеличивалось на 10%.
Измерения проводились до содержания влажности в почве 60%, так как при повышение влажности более этого
значения коды АЦП выводились некорректно. Результаты измерений приведены в таблице ниже.

Таблица - Результаты полученных данных
|=======================================================
| Влажность почвы, %|Код АЦП
|          0        |  2
|          10       |  300
|          20       |  587
|          30       |  760
|          40       |  947
|          50       |  1094
|          60       |  1200
|=======================================================

Для обработки полученных результатов и расчета по ним полинома был использован сервис _WolframAlpha_.

Произведем расчет полиномов 3 степени и определим наиболее подходящий.

Рассчитаем полином _3 степени_. Результат приведем на рисунке ниже:

.Рассчет полинома 3 степени.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::12.jpg[Sunset]

Таким образом, был получен полином: 1.6329*10^-8^*x^3^-5.9363*10^-6^x^2^+0.0333365*x-0.0580139 по которому и будет производиться расчет влажности.

На этом этапе завершается измерение влажности.

* _Задача отправления данных пользователю_

Отправление данных пользователю должно осуществляться по беспроводному интерфейсу _BlueTooth_.
_Bluetooth_ — это беспроводная персональная сеть передачи данных, которая используется для
сопряжения устройств, оснащенных специальными модулями. В основном его используют для того, чтобы передать те или иные данные с одного устройства на другое.Так же можно управлять устройствами на расстоянии без  проводов, соединять несколько устройств на достаточно большом расстоянии (до 100 метров).Для этого в работе выбран специальный  _BlueTooth_ модуль _BlueTooth Bee V2.0_ производителя _ElecFreaks_.
Его характеристики приведены выше.

Для передачи данных _BlueTooth_ модуль должен получать преобразованые данные влажности. Поэтому для
обмена данными между микроконтроллером и _BlueTooth_ модулем необходимо воспользоваться
универсальным синхронно-ассинхронным приемопередатчиком _(USART)_.

Универсальный синхронно-асинхронный приёмопередатчик — узел вычислительных устройств,
предназначенный для организации связи с другими цифровыми устройствами. Преобразует передаваемые
данные в последовательный вид так, чтобы было возможно передать их по одной физической цифровой
линии другому аналогичному устройству. Данный метод преобразования хорошо стандартизован и широко
применяется в компьютерной технике. Передача данных в _USART_ осуществляется по одному биту в равные
промежутки времени. Этот временной промежуток определяется заданной скоростью _USART_.
В выбранном микроконтроллере данный модуль является встроенным.

Перед отправкой данных пользователю, необходимо сформировать требуемое сообщение. Для этого создается
массив данных, который выглядит следующим образом: _Влажность почвы: ХХХ.ХХ [Units]_.

Для реализации отправки сформированного собщения необходимо сконфигурировать модуль USART.
Для этого необходимо:

** Подключить к шине тактирования модуль _USART_
** Настроить порты на альтернативную функцию работы с нужным модулем _USART_
** Настроить формат передачи данных
** Задать скорость передачи данных
** задать количество стоп битов,проверку четности
** Установить режим дескритизации
** Установить длину слова
** Разрешить передачу данных
** включить модуль _USART_

Таким образом будет происходить обмен данными между платой и _BlueTooth_ модулем, а с помощью
_BlueTooth_ модуля будет производиться передача данных пользователю в заданном формате.

Архитектура на рисунке 6 имеет две активные задачи: _HumidityTask_ и _BlueToothTask_. Они наследуют
обертку операционной системы реального времени _FreeRTOS_ — _Thread_.

_HumidityTask_ это активная задача,которая выполняется под руководством операционной
системы реального времени.Данная задача выполняет функцию измерения влажности почвы. Для этого
она раз в 100мс обращается к классу _Humidity_ и вызывает его для произвеления измерений.

Класс _Humidity_ выполняет преобразование отфильтрованных кодов АЦП в процентное значение
влажности. Для выпонения данной операции класс _Humidity_ обращается за отфильтрованными
значениями к классу _Filter_, а для получения текущих значений кодов АЦП к интерфейсу
_IDataSource_, который предаставляет значения, находящиеся в классе _ADC_.

Класс _Filter_ получает входной код, производит его фильтрацию и возвращает отфильтрованное
значение кода.

_IDataSource_ — это интерфейс, который предоставляет доступ к данным, получаемым с помощью АЦП.

Класс _ADC_ производит преобразование сигнала, получаемого с датчика влажности _Moisture Sensor_,
в цифровой вид, удобный для дальнейшего использования и преобразования.

_BlueToothTask_ - это активная задача,которая производит запрос данных у _HumidityTask_ и реализует
их отправку пользователю по интерфейсу BlueTooth c частотой один раз в 1000 мс в требуемом формате.
Для преобразования данных в требуемый формат задача обращается к классу _BlueTooth_.

Класс _BlueTooth_ производит преобразование данных, которые получены с _HumidityTask_ в
формат необходимый пользователю: _"Влажность почвы: ХХХ.ХХ"_. После произведенного преобразования
начинается отправка преобразованных даннных через интерфейс USART. За отправку сообщения по USART
отвечает класс _DriverUSART_.

Класс _DriverUSART_ - это класс, в котором реализуются функции отправки собщения, а также происходит
передача каждого последующего байта данных до окончания отправляемого сообщения. Для произведения
отправки сообщения необходимо включить передачу данных.За это отвечает класс _USART_.

Класс _USART_ позволяет записать в массив данные, которые необходимо передать, а также выполняет
включение передачи данных.

Таким образом, разработанная нами архитектура, позволяет выполнять поставленную задачу измерения
влажности почвы, соответствуя требованиям, выдвинутым в задании. Следующим этапом работы
является детальная разработка архитектуры каждого класса и написание рабочего кода.

== Класс _USART_

Класс _USART_ включает в себя 4 метода. Каждый из них реализует определенную задачу.
Класс содержит в себе шаблон _TUSARTReg_.Он позволяет сделать код данного класса более универсальным.
Подключая различные библиотечные файлы можно настроить на работу как модуль USART1, так и USART2 не внося
изменения в код программы.
Опишем каждый метод класса подробнее:

* Метод _WriteByte()_ производит запись данных, которые необходимо отправить, в регистр данных _DR_
микроконтроллера, а также ждет, пока не запишутся все данные, так как длина посылаемого сообщения
может изменяться.

* Метод _EnableTransmit()_ включает передачу данных путем установления бита _TE_  регистра _CR1_
в 1.

* Метод _SetSpeed()_ устанавливает скорость передачи данных по _USART_. Скорость может быть
различной. Она расчитывается по формуле: _СLK/(BaudRate*8*(2-OVER8))_, где

- _СLK_ - значение тактовой частоты микроконтроллера в герцах.
- _BaudRate_ - значение скорости передачи, которое необходимо установить.
- _OVER8_ - режим дискретизации (при установлении 1/16 записывается 0, а при установлении 1/8 - 1).

Затем полученное значение записывается в регистр _BRR_.

* Метод _DisableTransmit()_ производит выключение передачи данных. Для этого бит _TE_  регистра _CR1_
устанавливается в 0.

Архитектура класса _USART_ представлена на рисунке ниже:

.Класс USART.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::USART%20arch.jpg[Sunset]

Код класса _USART_ представлен ниже:

[,cpp]
----
#pragma once
#include <cstdint> // for uint8_t
//#include "itransmit.h" // for transmit


template <typename TUSARTReg>
class USART
 {
   public:
   void WriteByte (std::uint8_t byte) //записывает данные в регистр DR
    {
      TUSARTReg::DR::Write(byte);
      while(!TUSARTReg::SR::TXE::DataRegisterEmpty::IsSet())//ждем пока данные записываются
       {
       }
    }

   void EnableTransmit() //включает передачу данных
    {
      TUSARTReg::CR1::TE::Enable::Set();
    }

   void SetSpeed (std::uint16_t speed) //  устанавливает скорость передачи данных
    {
      speed = (8'000'000/(9600*8*(2 - 0))) << 4U;
      TUSARTReg::BRR::Write(speed);
      TUSARTReg::CR1::TE::Disable::Set();
    }

   void DisableTransmit() //выключает передачу данных
    {
      TUSARTReg::CR1::TE::Disable::Set();
    }
 };
----

== Класс _DriverUSART_

Клас _DrivrerUSART_ в своем составе имеет 3 метода. Данный класс содержит в себе ссылку
на класс _USART_. Он реализуется с помощью шаблона _aUsart_.

* Метод _SendMessage()_ реализует в себе включение передачи и отправку сообщения. В нем происходит
запись данных в массив, который формирует сообщение. Размер массива должен составлять не более 255
байт.Затем включается передача данных, в цикле передается каждый символ и
происходит отправка сообщения. После этого передача выключается.

* Метод _OnNextByteTransmit()_ производит запись данных в буфер для дальнейшей передачи.

* Метод _SetSpeed()_ записывает значение скорости передачи данных по USART.

Архитектура класса _DriverUSART_ представлена на рисунке ниже:

.Класс DriverUSART.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::DriverUSART.jpg[Sunset]

Код класса _DriverUSART_ представлен ниже:

[,cpp]
----
#include <cassert>
#include "USART.h" // for oUsart

template <auto& aUsart>
class  DriverUSART
 {
   public:
   void SendMessage (const char* message, std:: size_t aSize)//включение передачи и отправка сообщения
    {
      assert(size <= 255);
      size = aSize;
      memcpy(transmitBuffer, message, size);
      i=0U;
      aUsart.EnableTransmit();
      for(int j=0; j < size+1; j++)
      {
       OnNextByteTransmit();
      }
      aUsart.DisableTransmit();
    }

   void OnNextByteTransmit()//передача каждошо следующего байта данных
    {
      aUsart.WriteByte(transmitBuffer[i++]);
    }

   void SetSpeed(std::uint32_t speed)//записывает значение скорости передачи данных USART
   {
     aUsart.SetSpeed(speed);
   }

   private:
   std::size_t i=0U;
   std::uint8_t transmitBuffer[255]={};
   size_t size = 0U;
 };

inline DriverUSART<oUsart> usartDriver;
----

== Класс _BlueTooth_

Класс _BlueTooth_ содержит в себе один метод.Так же как и предыдущий,
данный класс содержит в себе ссылку
на класс _DriverUSART_. Он реализуется с помощью шаблона _aDriverUsart_.

* Метод _DataTransmit_ производит преобразование данных, в вид, требуемый пользователем и
начинает отправку сообщения. Для этого метод преобразует данные, полученные от класса _BlueToothTask_,
в строку и преобразует их в вид: _Влажность почвы: ХХХ.ХХ_ и затем начинает отправку сформированного
сообщения.

Архитектура класса _BlueTooth_ представлена на рисунке ниже:

.Класс BlueTooth.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::BlueTooth.jpg[Sunset]

Код класса _BlueTooth_ представлен ниже:

[,cpp]
----
#pragma once
#include <cstdio>
#include <iostream>
#include "DriverUsart.h"

template <auto& aDriverUsart>
class BlueTooth
 {
   public:
   void DataTransmit(float value)
    {
      char str[30] = {};
      sprintf(str, " Humidity: %4.3f \n", value);
      aDriverUsart.SendMessage(str, strlen(str));
    }
 };
----

== Класс _BlueToothTask_

Класс _BlueToothTask_ является активной задачей. Поэтому корректнее всего разделить его два файла
на файл где производится описание данного класса (файл _BlueToothTask.h_) и на файл, где описывается
реализация данного класса (файл _BlueToothTask.cpp_). Данный класс производит запрос данных для передачи
у _HumidityTask_ раз в 1000 мс, затем происходит событие - передача данных. Затем задача
переходит в спящий режим на 1000 мс.

Архитектура класса _BlueToothTask_ представлена на рисунке ниже:

.Класс BlueToothTask.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::BlueToothTask.jpg[Sunset]

Рассмотрим файл описания данного класса - файл _BlueToothTask.h_
Так как устройство работает под управлением операционной системы реального времени FreeRTOS
введем пространство имен OsWrapper.
Класс _BlueToothTask_ содержит метод _Execute()_ и конструктор _BlueToothTask()_.
Реализация метода _Execute()_ приведена в файле _BlueToothTask.cpp_.

Код файла _BlueToothTask.h_ представлен ниже:

[,cpp]
----
#pragma once
#include "thread.hpp"
#include <cstdio>
#include <iostream>
#include "usart2registers.hpp"
#include "chrono"
#include "event.hpp"
#include "HumidityTask.h"


using namespace OsWrapper;


class BlueToothTask : public Thread<128U>
 {
   HumidityTask& humidity;
   public:
   void Execute();
   BlueToothTask();
   BlueToothTask(HumidityTask& humidity);

 };
----

Рассмотрим файл реализации данного класса  - _BlueToothTask.cpp_.
Здесь класс _BlueToothTask_ содержит реализацию метода _Execute()_.
Метод _Execute()_ включает в себя бесконечный цикл. В нем реализуется получение значения с _HumidityTask_
и производится отправка полученного сообщения. Затем задача переходит в спящий режим на 1000 мс.
Конструктор _BlueToothTask()_ позволяет обратиться к классу _HumidityTask_.

Код файла _BlueToothTask.срр_ представлен ниже:

[,cpp]
----
#include "BlueToothTask.h"
#include "BlueTooth.h"


#include "Filter.h"

inline USART<USART2> oUsart;
inline DriverUSART<oUsart> usartDriver;
inline BlueTooth<usartDriver> bluetooth;



void BlueToothTask::Execute()
{
  for(;;)
   {
    bluetooth.DataTransmit(humidity.GetValueHumidity());
    Sleep(1000ms);
   }
}

BlueToothTask::BlueToothTask(HumidityTask& _humidity) : humidity(_humidity)
{
}
----

== Класс _ADC_

Класс _ADC_ отвечает за настройку работы АЦП через модуль DMA, а также возвращает полученный код.
Он содержит в себе шаблон _TDMA_. Он позволяет сделать код данного класса более универсальным.
Подключая различные библиотечные файлы можно настроить на работу как модуль DMA1, так и DMA2 не внося
изменения в код программы.
Данный класс содержит в себе два метода:

* Конструктор _ADC()_ производит настройку работы АЦП. Первым делом подается тактирование на модуль DMA.
Затем для корректной работы DMA указывпем адрес периферии с которой требуется получать данные, потом
задаем адрес памяти в которой будут сохраняться полученные данные. Укажем направление передачи данных
в данном случае направление передачи из периферии в память. Затем необходимо указать количество посылаемых
сообщений, так как производится одно измерение будет посылаться одно сообщение. Затем укажем размерность данных
периферии и данных памяти. Они составят 16 бит. Установим приоритет преобразования - очень высокий.
Разрешим работу DMA в циклическом режиме и работу 0 канала DMA. Запустим АЦП на преобразование.

* Метод _GetCode()_ возвращает полученное с АЦП значение кода.

Архитектура класса _ADC_ представлена на рисунке ниже:

.Класс ADC.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::ADC.jpg[Sunset]

Код класса _ADC_ представлен ниже:

[,cpp]
----
#pragma once
#include "rccregisters.hpp" // for RCC
#include "adc1registers.hpp"// for ADC
#include "dma2registers.hpp"

template<typename TDMA>
class ADC
 {
   public:
   ADC()
    {
      RCC::AHB1ENR::DMA2EN::Enable::Set();// разрешение тактирования для DMA2
      TDMA::S0CR::EN::Disable::Set();
      TDMA::S0PAR::Write(ADC1::DR::Address);// указываем адрес периферии
      TDMA::S0M0AR::Write(reinterpret_cast<std::uintptr_t>(&Code));// задаем адрес памяти
      TDMA::S0CR::DIR::Peripheraltomemory::Set(); // указываем направление передачи данных из переферии в память
      TDMA::S0NDTR::Write(1U); // количество пересылаемых сообщений
      TDMA::S0CR::PSIZE::Bit16::Set();// размерность данных периферии
      TDMA::S0CR::MSIZE::Bit16::Set();// размерность данных памяти
      TDMA::S0CR::PL::VeryHigh::Set();// приоритет - очень высокий
      TDMA::S0CR::CIRC::Enable::Set();// разрешаем работу dma в циклическом режиме
      TDMA::S0CR::EN::Enable::Set();// разрешаем работу 0 канала dma
      ADC1::CR2::SWSTART::On::Set();
    }

   uint32_t GetCode()
    {
      return Code;
    }

   private:
   std::uint32_t Code;
 };
----

== Класс _IDataSourse_

Класс _IDataSourse_ является интерфейсом. Он предоставляет доступ к данным из АЦП.
В своем составе он имеет один абстрактный метод.

* Абстрактный метод _GetCode()_ позволяет классу _Humidity_ получить доступ к данным, получаемым
при помощи АЦП и хранящимся к классе _ADC_.

Архитектура класса _IDataSourse_ представлена на рисунке ниже:

.Класс IDataSourse.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::IDataSource.jpg[Sunset]

Код класса _IDataSourse_ представлен ниже:

[,cpp]
----
#pragma once

class IDataSource
 {
   public:
   virtual void GetCode() = 0;
 };
----

== Класс _Filter_

Данный класс производит фильтрацию кодов АЦП. Он включает в себя два метода:

* Метод _Filter()_ является конструктором. В нем производится расчет постоянной фильтрации _tau_.
Она рассчитывается по формуле: _tau = 1-exp(-dt/RC)_, где

** _dt_ - это шаг дисретизации (выбрано значение равное 100),
** _RC_ - это постоянная времени (выбрано значение равное 1000).

Данная формула задана в техническом задании.

* Метод _Filtration()_ производит фильтрацию входного кода и возвращает отфильтрованное значение кода.
Отфильтрованное значение рассчитывается по формуле: _oldValue = oldValue + (Value - oldValue)*tau_, где

** _oldValue_ - хранит предыдущее отфильтрованное значение,
** _Value_ - хранит текущее значение кодов АЦП.

Данная формула задана в техническом задании.

Архитектура класса _Filter_ представлена на рисунке ниже:

.Класс Filter.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::Filter.jpg[Sunset]

Код класса _Filter_ представлен ниже:

[,cpp]
----
#pragma once

class Filter
 {
   public:
   Filter()
   {
     tau = float(1.0f - exp(-(dt)/(RC))); // формула для фильтрации
   };

   uint32_t Filtration(const uint32_t Value) //Value - текущее измеренное значение влажности
   {
     oldValue = oldValue + (Value - oldValue)*tau;
     return oldValue;
   };

   private:
   float oldValue; //хранит предыдущее отфильтрованное значение
   float tau; //постоянная фильтрации
   static constexpr float dt = 100.0f; //шаг дискретизации
   static constexpr float RC = 1000.0f; //постоянная времени
 };
----

== Класс _Humidity_

Этот класс рассчитывает значение по полученным из АЦП данным. В нем содержится два метода.
Данный класс содержит в себе ссылки на классы  _Filter_ и _IDataSource_. Они реализуются с помощью
шаблонов _aFilter_ и _DataSource_ соответственно. Рассмотрим каждый их методов в отдельности.

* Метод _GetValue()_ возвращает отфильтрованные и расчитанные данные.

* Метод _Calculate()_ производит преобразование отфильтрованных данных из АЦП в процентное значение
влажности. Для этого метод сначала получает данные с АЦП и производит их фильтрацию.
После фильтрации данных производит из расчет
используя полином третий степени: 1.6329*10^-8^*x^3^-5.9363*10^-6^x^2^+0.0333365*x-0.0580139 по которому и производился расчет. Вместо _х_ используется отфильтрованное
значение АЦП.

Архитектура класса _Humidity_ представлена на рисунке ниже:

.Класс Humidity.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::Hum.jpg[Sunset]

Код класса _Humidity_ представлен ниже:

[,cpp]
----
#pragma once
#include "Filter.h"
#include "ADC.h"
#include "IDataSource.h"
#include <iostream>


template <auto& aFilter, auto& DataSource>

class Humidity
 {
   public:
    void Calculate()
   {
     float FiltredValue = aFilter.Filtration(DataSource.GetCode());
     Value = ((1.6329*(pow(10,(-8))))*(pow(FiltredValue,3)))-((5.9363*(pow(10,(-6))))*(pow(FiltredValue,2)))+(0.0333365*FiltredValue)-0.580139;
   }

  float GetValue()
  {
    Calculate();
    if(Value<0)
    {
      Value=0;
    }
     return Value;
  }

 private:
  float Value;
 };
----

== Класс _HumidityTask_

Класс _HumidityTask_ также, как и _BlueToothTask_ является активной задачей. Поэтому также разделим его на два файла
файл _HumidityTask.h_ и на файл _HumidityTask.cpp_. Данный класс производит расчет значения влажности по кодам
АЦП и переходит в спящий режим на 100 мс.

Архитектура класса _HumidityTask_ представлена на рисунке ниже:

.Класс HumidityTask.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::HumTask1.jpg[Sunset]

Рассмотрим файл описания данного класса - файл _HumidityTask.h_.
Так как устройство работает под управлением операционной системы реального времени FreeRTOS
введем пространство имен OsWrapper.
Класс _HumidityTask_ содержит метод _Execute()_ , метод _GetValueHumidity()_ и конструктор _HumidityTask()_.
Реализация методов _Execute()_ и _GetValueHumidity()_ приведена в файле _HumidityTask.cpp_.

Код файла _HumidityTask.h_. представлен ниже:

[,cpp]
----
#pragma once
#include "thread.hpp"
#include <cstdio>
#include <iostream>
#include "rccregisters.hpp"
#include "adc1registers.hpp"
#include "chrono"
#include "event.hpp"
#include "HumidityTask.h"
#include "Humidity.h"
#include "Filter.h"
#include "ADC.h"
#include "dma2registers.hpp"

using namespace OsWrapper;


class HumidityTask : public Thread<128U>
 {
   public:
   void Execute();
   HumidityTask() = default;
   float GetValueHumidity();

// private:
//   Humidity<filter, adc> humidity;
 };
----

Рассмотрим файл реализации данного класса  - _HumidityTask.cpp_.
Здесь класс _HumidityTask_ содержит реализацию метода _Execute()_ и _GetValueHumidity()_.
Метод _Execute()_ включает в себя бесконечный цикл. В нем реализуется расчет значений
кодов АЦП во влажность. Затем задача переходит в спящий режим на 100 мс.
Метод _GetValueHumidity()_ возвращает расчитанное и отфильтрованное значение влажности.

Код файла _HumidityTask.cpp_ представлен ниже:

[,cpp]
----
#include "HumidityTask.h"
#include "Humidity.h"
#include "IDataSource.h"
#include "Filter.h"
#include "dma2registers.hpp"
#include "ADC.h"

ADC<DMA2> adc;
Filter filter;
Humidity<filter, adc> humidity;

void HumidityTask::Execute()
{
  for(;;)
   {
    GetValueHumidity();
    Sleep(100ms);
   }
}

float HumidityTask::GetValueHumidity()
{
  return humidity.GetValue();
}
----


== Основной код

Основной код программы и основные настройки необходимых элементов приведены в файле _main.cpp_.
В коде программы находится функция _low_level_init_ в ней происходит основная настройка элементов:

- подключение микроконтроллера к внешнему источнику питания;
- подключение модулей _USART_ и ножку канала, по которому производится измерение влажности, и модуля АЦП
к шине тактирования;
- Производится основная настройка модуля _USART_ (выбираем длину слова, режим дискретизации,
проверку четности, включаем модуль и включаем передачу);
- Производится настройка модуля АЦП (устанавливаем разрядность,непрерывное преобразование,
выбираем количество измерений, канал преобразования, скорость дискретизации, включаем модуль _DMA_,
включаем АЦП)

Затем создадим объекты классов _HumidityTask_ и _BlueToothTask_.

Так как устройство работает под управлением операционной системы реального времени FreeRTOS
введем пространство имен OsWrapper.

В функции _main()_ произведем настройку скорости передачи данных по _USART_. Для этого
используем функцию _SetSpeed()_ установим значение 38 400U, так как с данной скоростью происходит обмен
данными по выбранному BlueTooth модулю.
Затем создадим два потока данных под управлением операционной системы реального времени.
Один из потоков производит измерение влажности и в нем реализуется активная задача _HumidityTask_,
а второй - отправку измеренных данных,  нем реализуется задача _BlueToothTask_.
Они имеют нормальный приоритет выполнения.
Затем производится запуск операционной системы реального времени.

Код файла _main.cpp_ представлен ниже:

[,cpp]
----
#include "rtos.hpp"         // for Rtos
#include "mailbox.hpp"      // for Mailbox
#include "event.hpp"        // for Event
#include <iostream>
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp"  // for GPIOA
#include "gpiocregisters.hpp"  // for GPIOC
#include "BlueToothTask.h"
#include "adc1registers.hpp"
#include "HumidityTask.h"
#include "DriverUsart.h"
#include "HumidityTask.h"
extern USART<USART2> oUsart;
extern DriverUSART<oUsart> usartDriver;




std::uint32_t SystemCoreClock = 16'000'000U;

extern "C"
{
int __low_level_init(void)
   {
     RCC::CR::HSEON::On::Set();
     while(!RCC::CR::HSERDY::Ready::IsSet())
      {
      }

     RCC::CFGR::SW::Hse::Set();

     while(!RCC::CFGR::SWS::Hse::IsSet())
      {
      }

     RCC::CR::HSION::Off::Set();

     RCC::AHB1ENR::GPIOAEN::Enable::Set();
     GPIOA::MODER::MODER0::Analog::Set();
     RCC::APB1ENR::USART2EN::Enable::Set();
    GPIOA::MODER::MODER3::Alternate::Set();
    GPIOA::MODER::MODER2::Alternate::Set();
    GPIOA::AFRL::AFRL3::Af7::Set();
    GPIOA::AFRL::AFRL2::Af7::Set();
    GPIOA::PUPDR::PUPDR2::NoPullUpNoPullDown::Set();
    GPIOA::PUPDR::PUPDR3::PullUp::Set();
//     GPIOA::OTYPER::OT2::OutputPushPull::Set();
//     GPIOA::PUPDR::PUPDR3::PullUp::Set();
//     GPIOA::AFRL::AFRL2::Af7::Set();
     USART2::CR1::M::Data8bits::Set();
     USART2::CR1::OVER8::OversamplingBy16::Set();
     USART2::CR2::STOP::OneStopBit::Set();
     USART2::CR1::PS::ParityEven::Set();
     USART2::CR1::UE::Enable::Set();
//     USART2::CR1::TE::Enable::Set();

     RCC::APB2ENR::ADC1EN::Enable::Set();
     ADC1::CR1::RES::Bits12::Set();
     ADC1::CR2::CONT::ContinuousConversion::Set();
     ADC1::SQR1::L::Conversions1::Set();
     ADC1::SQR3::SQ3::Channel0::Set();
     ADC1::SMPR2::Write(4U);
     ADC1::CR2::DMA::Enable::Set();
     ADC1::CR2::DDS::DMARequest::Set();
     ADC1::CR2::ADON::Enable::Set();
     return 1;
   }
}


HumidityTask  humidityTask;

BlueToothTask bluetoothtask(humidityTask);

using namespace OsWrapper;

int main()
{
  usartDriver.SetSpeed(38400U);
  Rtos::CreateThread(humidityTask,"humidity", ThreadPriority::normal);
  Rtos::CreateThread(bluetoothtask, "bluetoothtask",ThreadPriority::normal);
  Rtos::Start();
  return 0;
}
----

== Вывод

В ходе работы было разработано устройство, позволяющее измерять
влажность почвы и передавать полученные данные пользователь по беспроводному
интерфейсу BlueTooth  формате "Влажность почвы: ХХХ.ХХ". Данное устройство обладает
всеми характеристиками, которые были заданы в техническом задании.

Отображение результата работы программы пользователю представлена на рисунке ниже:

.Результат программы.
[#img-sunset]
[link=https://github.com/MakarovSasha/Labs/blob/main/Curs]
image::Finish.jpg[Sunset]